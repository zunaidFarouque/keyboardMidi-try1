# ðŸ¤– Cursor Prompt: Phase 27.7 - Fix Injection Loop (Double Typing)

**Role:** Expert C++ Audio Developer (Win32 API).

**Context:**
*   **Current State:** Phase 27.6 Complete.
*   **The Bug:** When a device is set to "Passthrough", keys are typed twice (e.g., 'e' becomes 'ee').
*   **The Cause:** The `RawInputManager` is detecting the **Injected** key (sent by `InputInjector`) and treating it as a **New Physical** key, triggering a second injection loop. The previous `hDevice == 0` check is insufficient.
*   **Phase Goal:** Implement a strict **Signature Check** using `GetMessageExtraInfo()` to break the loop.

**Strict Constraints:**
1.  **Loop Breaking:** In `RawInputManager::rawInputWndProc`, call `GetMessageExtraInfo()` **before** doing anything else.
2.  **Signature:** If the extra info matches `0xFFC0FFEE` (our magic number), return immediately (ignore the event).
3.  **Verification:** Ensure `InputInjector` is actually sending this signature.

---

### Step 1: Update `RawInputManager.cpp`
Implement the strict filter.

**Refactor `rawInputWndProc`:**

```cpp
int64_t __stdcall RawInputManager::rawInputWndProc(void* hwnd, unsigned int msg, uint64_t wParam, int64_t lParam)
{
    // --- LOOP PREVENTION START ---
    // Check if this message was generated by our own SendInput call.
    // We must mask to 32-bit to correspond with how SendInput works.
    ULONG_PTR extraInfo = GetMessageExtraInfo();
    if ((extraInfo & 0xFFFFFFFF) == 0xFFC0FFEE)
    {
        // This is our own injected key. 
        // Let it pass to the default window procedure (so the app can type), 
        // but DO NOT process it in our MIDI/Logic engine.
        return CallWindowProc((WNDPROC)originalWndProc, (HWND)hwnd, msg, wParam, lParam);
    }
    // --- LOOP PREVENTION END ---

    if (msg == WM_INPUT)
    {
        // ... (Existing Raw Input Logic) ...
        // ... (hDevice check, buffer allocation, etc) ...
        
        // IMPORTANT: Ensure we don't accidentally inject again inside the logic
        // The existing logic: "if (passthrough) injectKey()" is fine 
        // ONLY because we filter the result of that injection above.
    }

    return CallWindowProc((WNDPROC)originalWndProc, (HWND)hwnd, msg, wParam, lParam);
}
```

### Step 2: Verify `SystemIntegrator.cpp` (The Hook)
Ensure the Hook is actually blocking the **Physical** key. If the Hook lets the physical key through *and* we inject a virtual key, we get double characters.

**Check `LowLevelKeyboardProc`:**
```cpp
// 1. Allow Injected Keys
KBDLLHOOKSTRUCT* p = (KBDLLHOOKSTRUCT*)lParam;
if ((p->dwExtraInfo & 0xFFFFFFFF) == 0xFFC0FFEE) 
    return CallNextHookEx(hHook, nCode, wParam, lParam);

// 2. Allow Toggle Key (Scroll Lock)
if (p->vkCode == allowedKey)
    return CallNextHookEx(hHook, nCode, wParam, lParam);

// 3. BLOCK EVERYTHING ELSE (If Midi Mode is Active)
// This prevents the Physical Key from typing 'e'
return 1; 
```

### Step 3: Verify `InputInjector.cpp`
Ensure the signature is set.

**Check `injectKey`:**
```cpp
// ...
input.ki.dwExtraInfo = 0xFFC0FFEE;
SendInput(1, &input, sizeof(INPUT));
```

---

**Generate code for: Updated `RawInputManager.cpp`, `SystemIntegrator.cpp`, and `InputInjector.cpp`.**